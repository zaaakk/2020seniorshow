<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - glTF loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>

  <body>

    <script type="module">

      import * as THREE from '../build/three.module.js';

      import { OrbitControls } from './jsm/controls/OrbitControls.js';
      import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
      import { RGBELoader } from './jsm/loaders/RGBELoader.js';
      import { RoughnessMipmapper } from './jsm/utils/RoughnessMipmapper.js';

      var container, controls, mesh;
      var camera, scene, renderer;

      init();
      render();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.0001, 1000 );
        camera.position.set( - 1.8, 0.6, 2.7 );

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.appendChild( renderer.domElement );

        controls = new OrbitControls( camera, renderer.domElement );
        controls.addEventListener( 'change', render ); // use if there is no animation loop
        controls.minDistance = 2;
        controls.maxDistance = 10
        controls.target.set( 0, 0, - 0.2 );
        controls.update();

        window.addEventListener( 'resize', onWindowResize, false );

        var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
        scene.add( light );
        var light2 = new THREE.AmbientLight( 0x404040 ); // soft white light
        scene.add( light2 );
        //background

        var geometry = new THREE.SphereBufferGeometry( 800, 60, 40 );
        // invert the geometry on the x-axis so that all of the faces point inward
        geometry.scale( - 1, 1, 1 );

        var texture = new THREE.TextureLoader().load( 'sidepano.png' );
        var material = new THREE.MeshBasicMaterial( { map: texture } );

        mesh = new THREE.Mesh( geometry, material );
      
        scene.add( mesh );

        mesh.rotation.y = -90;

        //gltf
        var loader = new GLTFLoader();
        loader.load(
          // resource URL
          'trinitytest.glb',
          // called when the resource is loaded
          function ( gltf ) {

            scene.add( gltf.scene );

            gltf.animations; // Array<THREE.AnimationClip>
            gltf.scene; // THREE.Group
            gltf.scenes; // Array<THREE.Group>
            gltf.cameras; // Array<THREE.Camera>
            gltf.asset; // Object
            gltf.scene.traverse( child => {

    if ( child.material ) child.material.metalness = 0;

} );
          },
          // called while loading is progressing
          function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

          },
          // called when loading has errors
          function ( error ) {

            console.log( 'An error happened' );

          }
        );

          //gltf2
        var loader = new GLTFLoader();
        loader.load(
          // resource URL
          'doors.glb',
          // called when the resource is loaded
          function ( gltf ) {

            scene.add( gltf.scene );

            gltf.animations; // Array<THREE.AnimationClip>
            gltf.scene; // THREE.Group
            gltf.scenes; // Array<THREE.Group>
            gltf.cameras; // Array<THREE.Camera>
            gltf.asset; // Object
            gltf.scene.traverse( function ( child ) {

    if ( child.isMesh ) { 

        child.material.alphaTest = 0.5;

     }

}  );
            gltf.scene.traverse( child => {

    if ( child.material ) child.material.metalness = 0;

} );
          },
          // called while loading is progressing
          function ( xhr ) {

            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

          },
          // called when loading has errors
          function ( error ) {

            console.log( 'An error happened' );

          }
        );
  
      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        render();

      }

      //

      function render() {

        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>